#' Visualises a Heat Map
#'
#' Uses results of the regression of cognition on hippocampal
#' structures. The object of this visualisation are s values with
#' a threshold s > 5 to signify potentially interesting relations.
#'
#' @param tab A table of regression coefficients and accompanying
#'    information as generated by \code{summarise_regressions}.
#' @param data A data frame with raw data generated by \code{import_data}.
#' @param help A list with helper files generated by \code{extract_helpers}.
#' @param rts A character vector of response time variables to be log-transformed
#'    as generated by \code{extract_rt_variables}.
#' @param pal A character indicating which colour scale to use. Either
#'    red tiles with blue asterisks (`"warm"` or `"sun"`, default) or
#'    blue tiles with red asterisks (`"cold"` or `"sea"`).
#'
#' @seealso [summarise_regressions()], [extract_helpers()], [import_data()],
#'    [extract_rt_variables()].
#'
#' @details
#' Whereas the `heatmap` will render a plot simply on calling it,
#' the scatter dot plots need to be plotted explicitly via
#' `plot(fig$scatters)` (see examples).
#'
#' @returns A list with two components:
#' \describe{
#'   \item{\code{heatmap}}{A {ggplot2} object containing a heatmap
#'   of all hippocampus structure/cognitive index available based on
#'   s values of the hippocampus * diagnosis interaction from a multiple
#'   regression analysis of the cognitive profile.}
#'   \item{\code{scatters}}{A gtable object containing scatter dot plot with
#'   cognition on ordinate and standardised hippocampi structure volume estimates
#'   on abscissa. Includes only cognition/hippocampus pairs with s > 5 fot the
#'   interaction term in a multiple regression of cognition on dignosis, hippocampus,
#'   and additive covariates.}
#' }
#'
#' @examples
#' \dontrun{
#' # Paths to files:
#' paths <- unlist(c(data_paths(), helper_paths())) |> purrr::keep(\(x) grepl("\\.", x))
#'
#' # Helpers:
#' H <- paths |>
#'   helper_paths() |>
#'   extract_helpers()
#'
#' # Data:
#' D <- paths |>
#'   data_paths() |>
#'   import_data(H)
#'
#' # Response time variables:
#' RTs <- extract_rt_variables(H)
#'
#' # Response summaries:
#' sums <- fit_regressions(
#'     preprocess_data(D, H, RTs, "df"),
#'     setup_regressions(H),
#'     H
#'   ) |> summarise_regressions()
#'
#' tab <- sums$`cognition|hippocampi`
#'
#' # Run the function:
#' figs <- draw_heatmap(tab, D, RTs, H, "warm")
#' figs1 <- draw_heatmap(tab, D, RTs, H, "sun") # the same as above
#' figs2 <- draw_heatmap(tab, D, RTs, H, "sea") # flipped colours
#'
#' # Show the plots:
#' figs$heatmap
#' plot(figs$scatter) # need to plot()
#' }
#'
#' @export
draw_heatmap <- function(tab, data, rts, help, pal = "warm") {
  # Extract helpers:
  for (i in names(help)) {
    assign(i, help[[i]])
  }
  # Prepare data table:
  t <- tab |>
    dplyr::mutate(
      side = dplyr::case_when(
        stringr::str_detect(x, "right") ~ "Right hemisphere",
        stringr::str_detect(x, "left") ~ "Left hemisphere"
      ),
      struct = factor(
        x = unlist(
          sapply(seq_len(dplyr::n()), function(i) {
            unique(hippo[hippo$name == x[i], "structure"])
          }),
          use.names = FALSE
        ),
        levels = hippo |>
          dplyr::arrange(desc(order)) |>
          dplyr::distinct(structure) |>
          dplyr::pull(),
        ordered = TRUE
      ),
      sect = factor(
        x = unlist(
          sapply(seq_len(dplyr::n()), function(i) {
            unique(hippo[hippo$name == x[i], "block"])
          }),
          use.names = FALSE
        ),
        levels = hippo |>
          dplyr::arrange(order) |>
          dplyr::distinct(block) |>
          dplyr::pull(),
        ordered = TRUE
      ) |>
        dplyr::recode(Parasubiculum = "", Complexes = " "),
      y = factor(
        x = unlist(
          sapply(seq_len(dplyr::n()), function(i) {
            psych[psych$variable == y[i], "label"]
          }),
          use.names = FALSE
        ),
        levels = psych$label,
        ordered = TRUE
      )
    )
  # Set-up colour gradient:
  if (pal == "warm" || pal == "sun") {
    palette <- c(star = "#08306b", low = "grey96", high = "#e34a33")
  } else if (pal == "cold" || pal == "sea") {
    palette <- c(star = "#b30000", low = "grey96", high = "#3182bd")
  }
  # Plot it:
  heatmap <- t |>
    ggplot2::ggplot() +
    ggplot2::aes(x = y, y = struct, fill = `s value`) +
    ggplot2::geom_tile() +
    ggplot2::geom_point(
      data = subset(t, `s value` > 5),
      ggplot2::aes(x = y, y = struct),
      shape = 8,
      colour = palette["star"],
      size = 2
    ) +
    ggplot2::scale_fill_gradient(low = palette["low"], high = palette["high"]) +
    ggplot2::labs(x = NULL, y = NULL) +
    ggh4x::facet_grid2(sect ~ side, scales = "free", space = "free") +
    ggplot2::theme_bw() +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, vjust = 1, hjust = 1))
  # Extract 'significant' results only:
  sigs <- subset(t, `s value` > 5) |>
    dplyr::arrange(desc(`s value`)) |>
    dplyr::select(y, x) |>
    dplyr::mutate(
      y_var = unlist(
        sapply(seq_len(dplyr::n()), function(i) {
          psych$variable[match(y[i], psych$label)]
        }),
        use.names = FALSE
      ),
      x_var = unlist(
        sapply(seq_len(dplyr::n()), function(i) {
          hippo$var[match(x[i], hippo$name)]
        }),
        use.names = FALSE
      ),
      y_lab = unlist(
        sapply(seq_len(dplyr::n()), function(i) {
          if (y_var[i] %in% rts) {
            as.character(glue::glue("log({y[i]})"))
          } else {
            as.character(y[i])
          }
        }),
        use.names = FALSE
      ),
      x_lab = unlist(
        sapply(seq_len(dplyr::n()), function(i) {
          hippo$full_name[match(x[i], hippo$name)]
        }),
        use.names = FALSE
      )
    )
  # Keep only relevant response time variables:
  rts <- rts[rts %in% unique(sigs$y_var)]
  # Prepare data for interactions plotting:
  d2 <- data |>
    dplyr::select(Study.ID, SUBJ, sBTIV, tidyselect::all_of(unique(sigs$y_var)), tidyselect::all_of(unique(sigs$x_var))) |>
    dplyr::mutate(
      dplyr::across(
        .cols = tidyselect::all_of(unique(sigs$x_var)),
        .fns = \(x) (x / sBTIV) * mean(sBTIV)
      ),
      dplyr::across(
        .cols = tidyselect::all_of(rts),
        .fns = \(x) log(x)
      ),
      Diagnosis = factor(
        x = dplyr::case_when(SUBJ == "PD" ~ "PD", SUBJ == "CON" ~ "HC"),
        levels = c("HC", "PD"),
        ordered = TRUE
      )
    ) |>
    dplyr::rename_with(
      .cols = tidyselect::all_of(unique(sigs$x_var)),
      .fn = \(x) hippo$full_name[match(x, hippo$var)]
    ) |>
    dplyr::rename_with(
      .cols = tidyselect::all_of(unique(sigs$y_var)),
      .fn = \(x) psych$label[match(x, psych$var)]
    ) |>
    dplyr::rename_with(
      .cols = tidyselect::all_of(na.omit(sigs$y[match(rts, sigs$y_var)])),
      .fn = \(x) glue::glue("log({x})")
    )
  # Prepare plots:
  interplots <- lapply(seq_len(nrow(sigs)), function(i) {
    d2 |>
      ggplot2::ggplot() +
      ggplot2::aes(
        x = .data[[sigs$x_lab[i]]],
        y = .data[[sigs$y_lab[i]]],
        colour = Diagnosis,
        fill = Diagnosis
      ) +
      ggplot2::geom_point(size = 1.5, shape = 21, colour = "black", alpha = .66) +
      ggplot2::geom_smooth(method = "lm", alpha = .22) +
      ggplot2::scale_fill_manual(values = c("deepskyblue", "red2")) +
      ggplot2::scale_colour_manual(values = c("deepskyblue", "red2")) +
      ggplot2::theme_bw(base_size = 8) +
      ggplot2::theme(legend.position = "none", panel.grid = ggplot2::element_blank())
  })
  # Pull the plots to a single figure:
  scatters <- gridExtra::arrangeGrob(grobs = interplots, ncol = 4, nrow = 5)
  # Return both plots:
  list(heatmap = heatmap, scatters = scatters)
}
